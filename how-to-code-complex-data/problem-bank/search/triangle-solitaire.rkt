#lang htdp/asl

(require racket/list)
(require 2htdp/image)
(require 2htdp/universe)

;; PROBLEM:
;;
;; The game of trianguar peg solitaire is described at a number of web sites,
;; including http://www.mathsisfun.com/games/triangle-peg-solitaire/#.
;;
;; We would like you to design a program to solve triangular peg solitaire
;; boards. Your program should include a function called solve that consumes
;; a board and produces a solution for it, or false if the board is not
;; solvable. Read the rest of this problem box VERY CAREFULLY, it contains
;; both hints and additional constraints on your solution.
;;
;; The key elements of the game are:
;;
;;   - there is a BOARD with 15 cells, each of which can either
;;     be empty or contain a peg (empty or full).
;;
;;   - a potential JUMP whenever there are 3 holes in a row
;;
;;   - a VALID JUMP  whenever from and over positions contain
;;     a peg (are full) and the to position is empty
;;
;;   - the game starts with a board that has a single empty
;;     position
;;
;;   - the game ends when there is only one peg left - a single
;;     full cell
;;
;; Here is one sample sequence of play, in which the player miraculously does
;; not make a single incorrect move. (A move they have to backtrack from.) No
;; one is actually that lucky!
;; (images removed)


;; ----------------------
;; Constants:

;; ------------- Game Configuration --------------

;; Board size represents the number of rows for the board
;; This should be greater than or equal to 4
;;
;; Default board size is going to be 5 (15 hole board) which can be changed as per the
;; following table:
;;
;; Board size -> Number of hole board
;; ----------------------------------
;;          4 -> 10
;;          5 -> 15
;;          6 -> 21
;;          7 -> 28
;;          8 -> 36
;;
;; NOTE: As this is a brute force algorithm, it is not recommended to set the value higher than 8.
(define BOARD-SIZE 5)

;; Represents the starting position on the board which is empty.
;; The number is a zero-based index of the positions on board.
;;
;;                                      Row number
;;                                     ------------
;;                 0                -->     1
;;               1   2              -->     2
;;             3   4   5            -->     3
;;           6   7   8   9          -->     4
;;        10  11  12  13  14        -->     5
;;      15  16  17  18  19  20      -->     6
;;    21  22  23  24  25  26  27    -->     7
;;  28  29  30  31  32  33  34  35  -->     8
;;
;; Default is 0: top spot empty
(define STARTING-POSITION 0)


;; -----------------------
;; Data definitions


;; Cell is Boolean (type alias)
;; interp. True represents a cell which contains the peg, false represents the absence of the peg

;; Board is (listof Cell)

(define-struct position (x y))
;; Position is (make-position Natural Natural)
;; interp. x and y position of a cell on the board where
;;         x represents the position on a specific row
;;         y represents the specific row on the board

(define-struct jump (from over to))
;; Jump is (make-jump Position Position Position)
;; interp. a jump on the board with the from, over and to position on the board


;; ------------------------
;; Functions:

;; Natural[4, ...] Natural[0, ...] -> (listof Board) or false
;; Return the list of boards to solution if the board is solvable, false otherwise.

(define (solve board-size starting-position)
  (local
    [
     (define possible-jumps (potential-jumps board-size))

     ; Board -> (listof Board) or false
     (define (helper-board board)
       (cond [(solved? board) (list board)]
             [else
               (letrec ([result (helper-list-of-board (next-boards board possible-jumps))])
                 (if (not (false? result))
                   (cons board result)
                   false))]))

     ; (listof Board) -> (listof Board) or false
     (define (helper-list-of-board list-of-board)
       (cond [(empty? list-of-board) false]
             [else
               (letrec ([try (helper-board (first list-of-board))])
                 (if (not (false? try))
                   try
                   (helper-list-of-board (rest list-of-board))))]))]

    (helper-board (construct-board board-size starting-position))))


;; Natural[4, ...] Natural[0, ...] -> Board
;; Construct the board given the board size and starting position on the board

(define (construct-board board-size starting-position)
  (build-list
    (sum-of-n board-size)
    (lambda (p) (not (= p starting-position)))))


;; Board -> Boolean
;; Determine whether the given board is solved or not.

(define (solved? board)
  (= (count (lambda (b) (boolean=? b true)) board) 1))


;; Board (listof Jump) -> (listof Board)
;; Return the next possible boards generated by making all the valid jumps

(define (next-boards board possible-jumps)
  (local
    [
     ; Jump -> Boolean
     (define (valid-jump? jump)
       (and (get-cell-content board (jump-from jump))
            (get-cell-content board (jump-over jump))
            (not (get-cell-content board (jump-to jump)))))

     ; Jump -> Board
     (define (apply-jump jump)
       (set-cell-content
         (set-cell-content
           (set-cell-content
             board (jump-from jump) false)
           (jump-over jump) false)
         (jump-to jump) true))]

    (map apply-jump (filter valid-jump? possible-jumps))))


;; ----------------------------------------------------------------
;; Algorithm to get all the potential jumps for a given board size
;; ----------------------------------------------------------------

;; Natural[4, ...] -> (listof Jump)
;; Produces all the possible jumps for the given board size
;; Raise error if board-size value not in POSSIBLE-BOARD-SIZE

(define (potential-jumps board-size)
  (if (< board-size 4)
    (error 'potential-jumps "contract violation\n  expected: >= 4\n  given: " board-size)
    (add-reverse-jumps
      (filter valid-potential-jump?
              ; Convert each value in a combination to Position on the board
              ; and convert the whole combination to a Jump.
              (map (lambda (combination) (apply make-jump (map index->position combination)))
                   (combinations (range (sum-of-n board-size)) 3))))))


;; (listof Jump) -> (listof Jump)
;; Return all the given jump and its respective reverse jump
;; Assumption: All jumps are valid

(define (add-reverse-jumps lst)
  (letrec ([reverse-jump
             (lambda (jump)
               (make-jump (jump-to jump) (jump-over jump) (jump-from jump)))])
    (append lst (map reverse-jump lst))))


;; Jump -> Boolean
;; Determine whether the given jump is valid or not

(define (valid-potential-jump? jump)
  (letrec ([from-pos-x (position-x (jump-from jump))]
           [from-pos-y (position-y (jump-from jump))]
           [over-pos-x (position-x (jump-over jump))]
           [over-pos-y (position-y (jump-over jump))]
           [to-pos-x (position-x (jump-to jump))]
           [to-pos-y (position-y (jump-to jump))])
    ; If all three pegs are in the same row
    (if (= from-pos-y over-pos-y to-pos-y)
      ; Check all three pegs are one after another
      (= (abs (- from-pos-x over-pos-x)) (abs (- over-pos-x to-pos-x)) 1)
      ; else, check all three pegs belongs to different row but should be one after another
      (and (= (abs (- from-pos-y over-pos-y)) (abs (- over-pos-y to-pos-y)) 1)
           ; and either, they belong to the left diagonal (same x coordinates)
           (or (= from-pos-x over-pos-x to-pos-x)
               ; or they belong to the right diagonal (x coordinate increase 1 in each row)
               (and (= over-pos-x (add1 from-pos-x)) (= to-pos-x (add1 over-pos-x))))))))


;; ---------------------------------------------------
;; Conversion: Index to position and position to index
;; ---------------------------------------------------

;; Natural -> Position
;; Convert the index to the position on the board

(define (index->position board-index)
  (local
    [
     ; Natural -> Position
     ; Convert the board index to its respective position (x and y) on the board
     (define (helper row-index)
       (letrec ([possible-row-indexes (board-indexes-in-row row-index)])
         (if (member board-index possible-row-indexes)
           (make-position (index-of possible-row-indexes board-index) row-index)
           (helper (add1 row-index)))))]

    (helper 0)))


;; Position -> Natural
;; Convert the Position value to the board-index

(define (position->index position)
  (+ (position-x position)
     (sum-of-n (position-y position))))


;; ----------
;; Helpers:
;; ----------

;; Natural -> Natural
;; Return the sum of n natural numbers using the formula:
;;
;;    n (n + 1)
;;    ---------
;;        2

(define (sum-of-n n)
  (/ (* n (add1 n)) 2))


;; Board (Position or Natural) -> Cell
;; Return the cell content for the given position on the given board
;; Position can be either Position or directly the index on the board

(define (get-cell-content board position)
  (if (position? position)
    (list-ref board (position->index position))
    (list-ref board position)))


;; Board (Position or Natural) Cell -> Board
;; Update the cell content of the given board at the given position with the given value
;; Position can be either Position or directly the index on the board

(define (set-cell-content board position value)
  (if (not (boolean? value))
    (error 'set-cell-content "contract violation\n  expected: boolean?\n  given: " value)
    (if (position? position)
      (list-set board (position->index position) value)
      (list-set board position value))))


; Natural -> (listof Natural)
; Return the list of all the indexes of the board present on the given row

(define (board-indexes-in-row row-index)
  (if (zero? row-index)
    (list 0)
    (letrec ([start (sum-of-n row-index)])
      (range start (+ start row-index 1) 1))))


;; ------------------
;; Animation section

(define MOVIE-RATE 1)
(define HOLE (circle 20 "outline" "black"))
(define PEG (overlay (circle 18 "solid" "blue") HOLE))


;; Natural[4, ...] Natural[0, ...] -> Image
;; Animate the solution from the starting board

(define (animate-solve board-size starting-position)
  (letrec ([solutions (solve board-size starting-position)])
    (if (false? solutions)
      (printf "false: This starting position is not solvable.")
      (run-movie
        MOVIE-RATE
        (map (lambda (board) (render-board board board-size)) solutions)))))


;; Board -> Image
;; Render an image of the given board
;; Assumption: Given board is of size BOARD-SIZE

(define (render-board board board-size)
  (foldr
    above
    empty-image
    (map (lambda (row)
           (foldr (lambda (p image)
                    (beside (if (get-cell-content board p) PEG HOLE)
                            image))
                  empty-image
                  row))
         (map board-indexes-in-row (build-list board-size identity)))))


;; ------------------------
;; Tests:

(define EMPTY-BOARD (build-list 15 (lambda (x) false)))
(define SOLVED-BOARD (build-list 15 (lambda (p) (= p 12))))

; 15 hole board initial position and possible next boards after BD15
(define BD15 (build-list 15 (lambda (p) (not (= p 0)))))
(define BD15a (build-list 15 (lambda (p) (not (or (= p 1) (= p 3))))))
(define BD15b (build-list 15 (lambda (p) (not (or (= p 2) (= p 5))))))

(check-expect (sum-of-n 0) 0)
(check-expect (sum-of-n 1) 1)
(check-expect (sum-of-n 3) 6)

(check-expect (get-cell-content SOLVED-BOARD (make-position 1 2)) false)
(check-expect (get-cell-content SOLVED-BOARD 4) false)
(check-expect (get-cell-content SOLVED-BOARD (make-position 2 4)) true)
(check-expect (get-cell-content SOLVED-BOARD 12) true)

(check-expect (set-cell-content EMPTY-BOARD (make-position 2 4) true) SOLVED-BOARD)
(check-expect (set-cell-content EMPTY-BOARD 12 true) SOLVED-BOARD)
(check-expect (set-cell-content SOLVED-BOARD (make-position 2 4) false) EMPTY-BOARD)
(check-expect (set-cell-content SOLVED-BOARD 12 false) EMPTY-BOARD)

(check-expect (board-indexes-in-row 0) (list 0))
(check-expect (board-indexes-in-row 1) (list 1 2))
(check-expect (board-indexes-in-row 5) (list 15 16 17 18 19 20))

(check-expect (index->position 0) (make-position 0 0))
(check-expect (index->position 1) (make-position 0 1))
(check-expect (index->position 2) (make-position 1 1))
(check-expect (index->position 4) (make-position 1 2))
(check-expect (index->position 7) (make-position 1 3))
(check-expect (index->position 13) (make-position 3 4))
(check-expect (index->position 14) (make-position 4 4))

(check-expect (position->index (make-position 0 0)) 0)
(check-expect (position->index (make-position 0 1)) 1)
(check-expect (position->index (make-position 1 1)) 2)
(check-expect (position->index (make-position 1 2)) 4)
(check-expect (position->index (make-position 1 3)) 7)
(check-expect (position->index (make-position 3 4)) 13)
(check-expect (position->index (make-position 4 4)) 14)

;; NOTE: We don't have to check whether the invariant holds true if the jumps are reversed as
;; the combination functions won't produce them in the first place. We are adding the reverse
;; jumps for all the valid forward jumps later.
(check-expect (valid-potential-jump?
                (make-jump (index->position 0)
                           (index->position 1)
                           (index->position 2))) false)
(check-expect (valid-potential-jump?
                (make-jump (index->position 0)
                           (index->position 2)
                           (index->position 3))) false)
(check-expect (valid-potential-jump?
                (make-jump (index->position 5)
                           (index->position 7)
                           (index->position 10))) false)
(check-expect (valid-potential-jump?
                (make-jump (index->position 3)
                           (index->position 8)
                           (index->position 14))) false)
(check-expect (valid-potential-jump?
                (make-jump (index->position 10)
                           (index->position 12)
                           (index->position 14))) false)
(check-expect (valid-potential-jump?
                (make-jump (index->position 0)
                           (index->position 1)
                           (index->position 3))) true)
(check-expect (valid-potential-jump?
                (make-jump (index->position 3)
                           (index->position 4)
                           (index->position 5))) true)
(check-expect (valid-potential-jump?
                (make-jump (index->position 4)
                           (index->position 7)
                           (index->position 11))) true)
(check-expect (valid-potential-jump?
                (make-jump (index->position 4)
                           (index->position 8)
                           (index->position 13))) true)
(check-expect (valid-potential-jump?
                (make-jump (index->position 2)
                           (index->position 5)
                           (index->position 9))) true)

; I have hand counted them on paper, the algorithm works :)
(check-expect (length (potential-jumps 4)) 18)
(check-expect (length (potential-jumps 5)) 36)
(check-expect (length (potential-jumps 6)) 60)
(check-expect (length (potential-jumps 7)) 90)
(check-expect (length (potential-jumps 8)) 126)

(check-expect (construct-board 4 0) (build-list 10 (lambda (p) (not (= p 0)))))
(check-expect (construct-board 5 12) (build-list 15 (lambda (p) (not (= p 12)))))

(check-expect (solve 4 0) false)
(check-expect (solve 4 4) false)
(check-expect (solve 5 0)
              '((#f #t #t #t #t #t #t #t #t #t #t #t #t #t #t)
                (#t #f #t #f #t #t #t #t #t #t #t #t #t #t #t)
                (#t #f #t #t #f #f #t #t #t #t #t #t #t #t #t)
                (#f #f #f #t #f #t #t #t #t #t #t #t #t #t #t)
                (#f #t #f #f #f #t #f #t #t #t #t #t #t #t #t)
                (#f #t #t #f #f #f #f #t #t #f #t #t #t #t #t)
                (#f #t #t #f #t #f #f #f #t #f #t #f #t #t #t)
                (#f #t #t #f #t #t #f #f #f #f #t #f #f #t #t)
                (#f #f #t #f #f #t #f #f #t #f #t #f #f #t #t)
                (#f #f #f #f #f #f #f #f #t #t #t #f #f #t #t)
                (#f #f #f #f #f #t #f #f #t #f #t #f #f #t #f)
                (#f #f #f #f #f #f #f #f #f #f #t #f #t #t #f)
                (#f #f #f #f #f #f #f #f #f #f #t #t #f #f #f)
                (#f #f #f #f #f #f #f #f #f #f #f #f #t #f #f)))

(check-expect (solved? EMPTY-BOARD) false)
(check-expect (solved? SOLVED-BOARD) true)
(check-expect (solved? (construct-board 4 0)) false)

(check-expect (next-boards BD15 (potential-jumps 5)) (list BD15a BD15b))
(check-expect (next-boards SOLVED-BOARD (potential-jumps 5)) '())


;; ---------------
;; (solve BOARD-SIZE STARTING-POSITION)
(animate-solve BOARD-SIZE STARTING-POSITION)
